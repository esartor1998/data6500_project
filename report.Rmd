---
title: "Report"
author: "Eric Sartor"
date: "`r Sys.Date()`"
header-includes:
  - \usepackage[numbers,sort&compress]{natbib}
  - \DeclareMathOperator{\norm}{norm}
output: pdf_document
bibliography: bibliography.bib
csl: ieee.csl
link-citations: true
---

## Introduction

### Description of the Plague

NOTES: please change the simulation back to normal when done. also return the DOWNLOAD FILES TO NORMAL

The Second Pandemic, otherwise known as the Black Death, played a key role in the shaping of late Medieval Europe and the world as we know it today. A devastating disease, known in historical sources simply as "plague" or "plagas", killed 40% of Europe's population just between 1347 and 1352 @Jedwab.etalPandemicsPlacesPopulations2019, and which continued to afflict Europe in waves until the 19th century. The bacterium responsible for the disease, *Yersinia pestis*, can cause 3 forms of plague in humans, all of which present at first with common flu symptoms. Bubonic plague, the most common outcome of infection @EvansPneumonicPlagueIncidence2022, with the most spectacular presentation of this form being painful, blackened, and swollen lymph nodes known as buboes. While mortality resulting from the bubonic form is only moderate, untreated bubonic plague may also develop into one of the other two forms of the disease @WorldHealthOrganizationPlague. Pneumonic plague, the second most common form of the disease, occurs when the lungs become infected; symptoms commonly include chest pain, shortness of breath, and the coughing of blood. This form is nearly 100% fatal, becoming untreatable even to modern medicine within 24-36h of the onset of symptoms. While other forms of the disease have an incubation period of 2-8 days, onset of symptoms for the pneumonic form can be within as little as 24 hours of infection @A.D.A.M.Inc.Plague, with death following shortly thereafter @Pechous.etalPneumonicPlagueDarker2016. The rarest form of plague, septicemic, results when *Yersinia pestis* multiplies in the blood. Uniquely, this variant causes the necrosis of tissues, and internal organ failure. 

While it is more treatable than pneumonic plague, in the Middle Ages, as no treatment was known for any form of the disease, it shared pneumonic plague's certain mortality. 
The disease is spread most commonly through the bite of an infected rat flea, though it can also be spread in its pneumonic form from person-to-person @WorldHealthOrganizationPlague. Evidence also indicates that human fleas can also be a vector for the disease, and can both receive it from and transmit it to humans @Hufthammer.WalloeRatsCannotHave2013, with SIR modeling demonstrating that a model based on transmission through human ectoparasites is similar in fit to one based on transmission through rat fleas [@Dean.etalHumanEctoparasitesSpread2018; @Sichone.etalEstimatingBasicReproduction2020]

The recent digitization of a substantial volume of plague records @Buntgen.etalDigitizingHistoricalPlague2012 alongside new fine-grained population estimate rasters for pre-census periods through the HYDE project @kleingoldewijkAnthropogenicLandUse2017 allow for myriad novel analysis of the Second Pandemic. Through analysis of the characteristics and traits of the disease in a time when effective medical treatment for most diseases was completely unknown, further knowledge regarding societal responses to disease as well as the effect of unchecked disease on a population can be studied. Additionally, knowledge of the true severity of the disease throughout various regions of Europe can help to provide historical context for events and developments in the region throughout the Middle Ages. Furthermore, given the severity and gruesome nature of the disease, modelling its spread through and impact upon Medieval Europe may prove a sobering reminder of the potential severity of an incurable epidemic. 

### Data Sources

* A digitized plague mentions dataset, including both mentions and well-known maritime trade routes @schmidSourceCodeDatasets2015 compiled for the paper "Climate-driven introduction of the Black Death and successive plague reintroductions into Europe" @schmidClimatedrivenIntroductionBlack2015
* HYDE 3.2 @kleingoldewijkAnthropogenicLandUse2017, a monumental collection of rasters, encoding global environmental conditions and other information, including the most recent historical population and population density estimates currently available for pre-census periods. The rasters are available in 100-year intervals during the period of interest, at a resolution of 85km$^2$.
* Approximate European borders shapefile for 1279 from a ThinkQuest educational web-site design competition held in 2000 @ThinkQuestTeamC006628TeachingHistoryGIS2000. While this data is entirely student-created and may present minor inaccuracies, as it is used simply for the purposes of aiding in visualization, this is not a major concern.
* Basemap tilesets for visualization by Apple, through `tmaptools` @tennekesTmaptoolsThematicMap2021

## Methods

### Preliminary Work Motivating the Model

Unless otherwise specified, all analyses were performed using the R language @rcoreteamLanguageEnvironmentStatistical2023. 
Firstly, a raster containing the population difference between 1300AD and 1400AD was computed. This raster, visible in Figure (???), is variously referred to in this report as the "death raster", or "population difference raster". It represents the loss or gain in population count in each cell over the 14th century as estimated by the HYDE. One would normally expect wholesale population growth, but as a result of the devastation wrought by the Second Pandemic, the population difference raster is mostly negative, with population gain generally only in more remote regions. 
As a result of this, and given the generally small magnitude of the population gain, a model purely estimating deaths rather than attempting to include population gain as well was used to massively simplify the required calculation.

Next, in order to assess sanity of the outbreak data, as well as its correlation with the HYDE estimates, Poisson point process methods were used to generate an intensity (points per unit area) estimate for the outbreak data as a function of the death raster. Specifically, the outbreak data preceding 1400AD was interpreted as a single Poisson point process, and a nonparametric intensity estimate was taken through `spatstat`'s `rhohat` function @baddeleySpatstatPackageAnalyzing2005. Then, a raster was computed depicting the predicted intensity at every cell in the death raster, resulting in Figure (???). This informed the usage of the outbreak data in general, providing confidence that it was correlated with deaths. Further, some authors cast doubt upon the usefulness of the Schmid et al data, stating that it may be missing key outbreaks in Europe, as the intensity of the points in Northern Italy in their opinion did not align with other historical accounts @roosenDangersNoncriticalUse2018. This analysis, however, finds a high intensity in the allegedly problematic regions, providing confidence that the usage of the outbreak data is not detrimental to the legitimacy of any results.

Additionally, it is significant that the death raster is quite similar to the population density raster for the year 1300AD, as the population difference raster is generated only using population count data: this explicitly points to population density as a key factor in the relationship. In order to further assess the nature of the relationship between population density and population difference, focal correlation between the two rasters was assessed using the `focalPairs` function available through `terra` @hijmansTerraSpatialData2023, and is visible in Figure (???). While a negative correlation between population density and population growth was expceted, the positive correlation found in some regions indicates that difficult-to-model factors such as migration may be present. (SAY more about this?) 

### Deterministic Model

The model is run on each outbreak year chronologically. While technically a recursive algorithm, it is not implemented as such in order to save resources during processing. All generated rasters are identical in dimension to the population density and count rasters obtained through the HYDE, and no downscaling is performed. Additionally, all calculations are performed on unprojected data, as `terra`'s `distance` function is significantly more accurate with unprojected data than on projected data. The $\norm{}$ function represents the uniform scaling, or normalization, of a value to between 0.0 and 1.0, and is defined by $\frac{x - \min{(x)}}{\max{(x)} - min{(x)}}$.

Firstly, the outbreak points for ${year}$ are taken, and a raster $dist_{rast}$ is computed where the value of each pixel is inversely proportional to their distance from the closest outbreak according to $h = \exp({-m\norm{(ad^{x}})})$, where $d$ is the closest distance to an outbreak point returned for each pixel by `terra`'s `distance` function. $m$ $a$ and $x$ are scaling parameters for which various values are tested: $m$ scales the largest negative value that $e$ can be raised to, $a$ increases the area underneath the curve close to the $y$ axis by "lifting" the graph upwards, and $x$ disproportionately increases the value returned for pixels extremely close to the closest outbreak point. Effectively, $m$ and $a$ scale the overall range of an outbreak's effect, while $x$ scales the distance where the outbreak will be the most devastating.

Before describing how the estimated infected population raster is calculated, it is imperative to define several other rasters as well. The susceptible population density raster, $dens_{rast}$, wherein each cell's value represents the density of susceptible individuals within any given cell. The initial value of $dens_{rast}$ is the population density in 1300AD. The susceptible population _density_ raster is recalculated each year based upon $S_{rast}$, the susceptible population _count_ raster. The initial value of this raster is the population count in 1300AD.

Next, the infected population estimate raster $I$ is calculated, by $s(dens_{rast})(dist_{rast})$. The density and distance rasters are multiplied together, cell-by-cell, as well as by a normalized scalar parameter, $s$, representing the maximal yearly saturation percentage within susceptible individuals; this value is tested multiple times between 0.0 and 1.0. $s$ exists as according to current scholarship, even the cities hit most severely with plague only lost at most 50-80% of their populations [@CohnEpidemiologyBlackDeath2008; @DorseyArmstrongHowPolandMilan2021; @Cesana.etalOriginEarlySpread2017; @Roosen.CurtisLightTouchBlack2019; @Jedwab.etalPandemicsPlacesPopulations2019].
It is crucial to note that $dens_{rast}$ is not normalized, thus cells with a high density of susceptible individuals will be struck most severely with plague. However, because the susceptible population density is adjusted each iteration, this is seen most acutely when the area experiences its first outbreak. Additionally of note is that the value of $dist_{rast}$ approaches 0 at an exponential rate with distance to a recorded outbreak, allowing the progression of the disease to roughly follow the point pattern present in the outbreaks dataset, and for the countryside to be less severely affected than denser, more urban areas where outbreaks are typically recorded.

The final step each iteration is to adjust each population, as well as the population density, before recursing. $I$ is subtracted from $S$, as a person cannot be reinfected with any form of the plague, either because they have died, or because they have become immune to all forms after surviving an infection. 
Following this, the newly modified $S$ is utilized to create a new $dens_{rast}$ for the next iteration. However, this is not as straightforward as it seems: even though the data is unprojected, the ellipsoid indexed by the longitude and latitude coordinates is not a perfect sphere and is instead flatter at the poles. Thus, some cells  actually represent a larger geographic area than others, and the true geographic area represented needs to be calculated so that the population density is not skewed positively towards the poles. Luckily, `terra`'s `cellSize` is a quick and effective way to obtain the true geographic size of a raster cell, provided that it is sufficiently small. However, this alone still does not perfectly convert population to population density, as the HYDE uses other sources in addition to population count to estimate population density. As a result, we also need to offset by the initial difference between a population density calculated using only population count, and the HYDE estimate for population density. 
With all this complete, $I$ is multiplied by $mortality$ in order to estimate the number of those infected who will die; for this simulation, a scalar $mortality = 0.8$—or 80%—was used. This is based upon various estimates of the average contemporary mortality rate across all forms of the disease [@Pechous.etalPneumonicPlagueDarker2016; @EvansPneumonicPlagueIncidence2022; @Dean.etalHumanEctoparasitesSpread2018; @TotaroSufferingParadiseBubonic2005; @CohnEpidemiologyBlackDeath2008]. The resulting raster, $D$, represents only the dead individuals from the outbreak year currently analysed, not the cumulative number of deaths over the entire epidemic. All yearly $D$ rasters must be summed at the end of recursion in order to compute a total estimate.
Finally, recursion is then performed until the final desired year is reached.

- describe the model's terms, the motivation behind each + each normaliz8n
- describe the formula for the model
- describe the temporal factor(s)
- make it a statistical model?


## Results

### Prelim Results ?

### Deterministic Model Results

- note the implications behind the parameters which were successful, esp. that worst_case.
- note that mortality wasnt really hugely influential, or at least not as influential as raising effectiveness over distance

```{r setup, include=FALSE, echo=FALSE}
library(sf)
library(sp)
library(maptools)
library(terra)
library(tidyverse)
library(osmdata)
library(tmap)
library(tmaptools)
library(rjson)
library(spatstat)
library(raster)
library(utils)
#some "important" "globals" and setup
#NOTE: much of this code is reused from my EDA/presentation code, with large
#chunks cut out of it because they weren't necessary to do in this report
tmap_mode('plot')
projected_crs = 'EPSG:3857'
unprojected_crs = 'EPSG:4326'

unproj_bbox = bbox = st_bbox(c(xmin = -16.26,
                 xmax = 42.98,
                 ymin = 27.92,
                 ymax = 61.54),
                 crs=unprojected_crs) %>%
       st_as_sfc()

bbox = unproj_bbox %>%
       st_transform(projected_crs)

cropping_bbox = vect(bbox)
up_cbbox = vect(unproj_bbox)

milan_location = st_point(c(45.4643, 9.189), dim='XY') %>%
                 st_sfc() %>%
                 as_Spatial()
crs(milan_location) = 'EPSG:3857' #NOTE: this is specifically in web mercator proj.

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, error = FALSE)
```

```{r download_and_prep_data, echo=FALSE, include=FALSE}
basemap = read_osm(bbox, type='apple-iphoto', mergeTiles=TRUE)
#should maybe project these too if i go back to that

#download.file('https://a.scrunko.monster/ZIwO3/HEhiticO76.csv/raw',
#              './combined-maritime-traderoutes.csv')
maritime_routes_sf = read_sf('./combined-maritime-traderoutes.csv')
st_crs(maritime_routes_sf) = unprojected_crs
maritime_routes_sf = st_transform(maritime_routes_sf, unprojected_crs) %>%
                     st_crop(unproj_bbox)

#download.file('https://github.com/kgjenkins/tq-world-historical-boundaries/raw/master/1279.zip', 
#              './1279_borders.zip') #download directly from an archive, as streaming from my server
                                    #crashes on windows (i think some sort of php bug on the serv.)
                                    #note: make sure to cite this archive in the bibliography!! 
#unzip('./1279_borders.zip')
borders = read_sf('./cntry1279.shp')
st_crs(borders) = unprojected_crs
borders = st_transform(borders, unprojected_crs) %>%
          st_crop(unproj_bbox)

#download.file('https://a.scrunko.monster/ZIwO3/Lanidubi78.asc/raw',
#              './popc_1300AD.asc')
ad1300_popc_rast = rast('./popc_1300AD.asc') %>%
                   terra::project(unprojected_crs) %>%
                   crop(up_cbbox) #%>%

units(ad1300_popc_rast) = 'ppl/cell'

#download.file('https://a.scrunko.monster/ZIwO3/mIMuROme20.asc/raw',
#              './popd_1300AD.asc')
ad1300_popd_rast = rast('./popd_1300AD.asc') %>%
                   terra::project(unprojected_crs) %>%
                   crop(up_cbbox)

units(ad1300_popd_rast) = 'ppl/km²'

#download.file('https://a.scrunko.monster/ZIwO3/CAYoYISe01.asc/raw',
#              './popc_1400AD.asc')
ad1400_popc_rast = rast('./popc_1400AD.asc') %>%
                   terra::project(unprojected_crs) %>%
                   crop(up_cbbox)

units(ad1400_popc_rast) = 'ppl/cell'

#download.file('https://a.scrunko.monster/ZIwO3/RiBOJiMa99.txt/raw',
#              './plague-db-europe.txt')

death_raster = ad1400_popc_rast - ad1300_popc_rast
```


```{python process_plague_info, echo=FALSE}
import re
import os

if not (os.path.exists('./plague_reprocessed.json')):
  with open('./plague-db-europe.txt', 'r') as plague_data:
    plague_data_text = plague_data.read()
    processed = re.sub(r'\:([a-zA-Z]+)', r'"\1":', plague_data_text)
    processed = re.sub(r'} ', r'}, ', processed)
    with open('./plague_reprocessed.json', 'w') as outfile:
      n = outfile.write(processed)
      outfile.close()
```


```{r read_plague_info, echo=FALSE}
library(jsonlite)
library(readr)

json_raw   = readr::read_file("./plague_reprocessed.json")
json_lines = unlist(strsplit(json_raw, "\\n"))
plague_df = do.call(rbind, lapply(json_lines, #god what a hack
                                  FUN = function(x){as.data.frame(jsonlite::fromJSON(x))})) 
plague_sf = st_as_sf(x=plague_df, 
                        coords=c('lon', 'lat'),
                        crs=unprojected_crs)

plague_occurrence_ordered = plague_sf[order(plague_sf$name, plague_sf$year, decreasing=FALSE),]
plague_occurrences_by_year = plague_occurrence_ordered %>%
                            group_by(year) %>%
                            arrange(year)

first_occurrences = plague_occurrences_by_year[!duplicated(plague_occurrences_by_year$name),] %>%
                    rename(first_occurrence = year) %>%
                    data.frame() %>%
                    subset(select=-c(geometry, source))

plague_occurrences_by_year = merge(plague_occurrences_by_year, first_occurrences, by='name')

target_occurrences = plague_occurrences_by_year[which(plague_occurrences_by_year$year <= 1400),]

#thanks to baseR for the following function actually
target_occurrences['is_reoccurrence'] = duplicated(target_occurrences$name)
occurrence_count = as.data.frame(table(target_occurrences$name))
occurrence_count = rename(occurrence_count, name = Var1)
target_occurrences = merge(target_occurrences, occurrence_count, by='name', all.x=T) %>%
                          rename(n_occurrences = Freq)
#only interested in years before 1400 right now

target_occurrences = st_as_sf(target_occurrences) %>% 
                    st_crop(unproj_bbox) %>%
                    arrange(year)

all_target_years = target_occurrences[which(target_occurrences$year <= 1400),]
```


```{r garbage_collection, echo=FALSE, include=FALSE}
#just to clean up exec environment of tempvars. 
#ik if i used more piping i wouldnt have to do this, but i don't care atm
rm(plague_occurrence_ordered)
rm(plague_occurences_by_year)
rm(occurrence_count)
rm(target_occurrences)
rm(plague_df)
rm(plague_sf)
rm(json_raw)
rm(json_lines)
```

```{r death_raster, echo=FALSE}
tm_shape(basemap) + tm_rgb(alpha = 0.8) + tm_shape(death_raster, raster.downsample=FALSE) + tm_raster(alpha=0.7,
                                                                  breaks=c(-51200.0
                                                                          -25600.0,
                                                                          -12800.0,
                                                                          -6400.0,
                                                                          -3200.0,
                                                                          -1600.0,
                                                                          -800.0,
                                                                          -400.0,
                                                                          -200.0,
                                                                          -100.0,
                                                                            0.0,
                                                                           100.0,
                                                                           200.0,
                                                                           400.0,
                                                                           800.0,
                                                                           1600.0),
                                                                  title="") +
        tm_layout(legend.position=c("left", "top"),
                  frame=FALSE,
                  legend.outside=TRUE,
                  legend.bg.alpha=0.6,
                  main.title='Pop. Diff 1400AD-1300AD')
```



```{r focal_correlation_between_deaths_and_popd, echo=FALSE}
death_on_popd = rast(list(ad1300_popd_rast, death_raster))
crs(death_on_popd) = unprojected_crs
correlation = focalPairs(death_on_popd, w = 3, cor) #WARNING: this may crash if your libraries are not up-to-date!

tm_shape(basemap) + tm_rgb(alpha=0.8) + tm_shape(correlation, raster.downsample=FALSE) +
  tm_raster(alpha=0.7, palette="Spectral", title="") + 
  tm_shape(borders$geometry) + tm_borders(alpha=0.5) + 
  tm_layout(legend.position=c("left", "top"),
            frame=FALSE, 
            legend.bg.alpha=0.6,
            legend.outside=TRUE,
            main.title="Focal Correlation Between\nDeaths and 1300AD Pop. Dens.")
```

```{r predicted_intensity_through_rhohat, echo=FALSE}
#first we gotta project the data. I'm choosing ED1950 Albers, as it covers the target area decently
death_raster_proj = death_raster %>%
                    terra::project(projected_crs)

death_raster_im = death_raster_proj %>%
                  raster() %>%
                  as.im.RasterLayer()

target_years_proj = all_target_years %>%
                    st_transform(projected_crs)

outbreak_ppp = target_years_proj %>%
              dplyr::select(is_reoccurrence, year) %>%
              mutate(year=factor(year)) %>%
              mutate(is_reoccurance=factor(is_reoccurrence)) %>%
              as.ppp()

rh = rhohat(outbreak_ppp, death_raster_im)

predrast = rast(predict(rh)*10e8) #many values are very small
crs(predrast) = projected_crs
tm_shape(basemap) + tm_rgb(alpha=0.8) + tm_shape(predrast, raster.downsample=FALSE) +
                                        tm_raster(alpha=0.7,
                                                  breaks = c(0,0.1,0.2,0.3,0.4,0.5,0.6), 
                                                  palette = 'Spectral',
                                                  title = 'Intensity') +
  tm_shape(borders$geometry) + tm_borders(alpha=0.5) + 
  tm_layout(legend.position=c('left', 'top'),
            frame=FALSE,
            legend.outside=TRUE,
            main.title='14th Century Predicted Intensity')
```


spatial autocorrelation in the fact that outbreaks are considered based on distance from the pixel, and that there is s.ac. in the density/count data

i *cannot* use linear population density scaling: *each cell's original size is warped by the ellipsoid*; as such, i need to obtain a per-pixel scaling value to convert pop to popd. luckily, terra has a "cellsize" function we can use to calculate


starting 1300, for each year:
- foreach pixel in population raster:
  - scale/generate r0 using known r0, distance from outbreaks, popd, prev. r0 at that pixel
  - apply this r0 and use fatality rate etc to gen. a new value at the px loc.
    - also generate a new population density for the tile.

- this does not account for migration in/out of cities as a result of population loss

- does not account for saturation of popd. as a proxy for contacts

-need to programmatically run this multiple times, with multiple different parameters, to compare

```{r run_simulations, echo=FALSE, include=FALSE}
#scaling for raster cells is spatially warped:
popc_cell_size = terra::cellSize(ad1300_popc_rast, unit='km')
#cell size shouldn't change, so we only need to do this one time
#additionally, wemust offset here, as the data used to obtain popd uses more sources than just popc
popd_offset = (ad1300_popc_rast / popc_cell_size) - ad1300_popd_rast
#so, we need to generate an offset raster representing the initial starting offset from 
#popc/cellsize present in the data, and then apply that retroactively going forward in the conv.

normalize_rast = function(rast) {
  m = terra::minmax(rast) #m[1] is min, m[2] is max
  return((rast - m[1])/(m[2] - m[1]))
}

popc2popd = function(popc_rast) {
  return((popc_rast / popc_cell_size) - popd_offset)
} #subtracting 1300_popd is valid, as that is the last known offset to the true number

year2idx = function(year) {
  return(which(recorded_years == year))
} #convenience function for converting a year number to its results-index

target_years = all_target_years[which(all_target_years$year > 1345 &
                                      all_target_years$year <= 1400),]
recorded_years = unique(target_years$year)
first_year = recorded_years[1]

d_smoothing = c(0.4, 0.6, 0.8)
              #seq(0.40, 0.80, by=0.2) #size of the region extremely close to 1.0 in distance raster
d_coeff =     c(6, 8, 10)
              #seq(6, 10, by=2) #size of the overall region above d_threshold in distance raster
d_max_range = c(3, 6)

worst_case =  c(0.5, 0.9)
              #seq(0.5, 0.9, by=0.2) #estimated maximum yearly saturation % of infection among S
mortality   = c(0.8) #@TotaroSufferingParadiseBubonic2005
              #seq(0.4, 0.8, by=0.2) #estimated average mortality over all forms contracted

#non-tunable params
d_threshold = 0.01 #value at which we would like to round to 0, to prevent global infection

params = crossing(d_smoothing, d_coeff, worst_case, mortality)
iter=0
susc_maps = list()
final_dead = list()
correlations = list()
for (trial in split(params, seq(nrow(params)))) {
  iter = iter + 1
  susceptible = list()
  infected = list()
  recovered = list()
  dead = list()
  susd = list()
  maps = list()
  for (year in recorded_years) {
    curr_idx = year2idx(year) #NOT: not the idx in targ_years, just iter#
    prev_idx = curr_idx - 1
  
    prev_years_outbrks = target_years[which(target_years$year <= year),]
    curr_year_outbrks = target_years[which(target_years$year == year),]
  
    #the variable we will use to hold this year's susceptible population estimate raster
    susc_tmp = if(length(susceptible) == 0) ad1300_popc_rast else susceptible[[prev_idx]]
    
    #the variable we will use to hold this year's S population density estimate raster
    susd_tmp = normalize_rast(
      if(length(susd) == 0) ad1300_popd_rast else susd[[prev_idx]]
    )
  
    #the raster used to scale distance from an outbreak
    dist_rast = exp(1)^(-3 * normalize_rast(
      trial$d_coeff*terra::distance(susc_tmp, vect(curr_year_outbrks), rasterize=T)^trial$d_smoothing
    ))
    dist_rast[dist_rast < d_threshold] = 0
    
    #the "infectiousness raster" we can use as a term in our estimate of the number of dead/infected
    infn_rast = trial$worst_case * dist_rast * susd_tmp
    
    #the estimate of the infected. should i use terra::predict, or...?
    infected[[curr_idx]] = floor(infn_rast * susc_tmp)
    #and, the other values associated:
    susceptible[[curr_idx]] = susc_tmp - infected[[curr_idx]] #even if survived, cant be reinfected
    dead[[curr_idx]] = mortality * infected[[curr_idx]]
    recovered = infected[[curr_idx]] - dead[[curr_idx]] #R,D not really used, but hey. good 2 know
    
    #we musn't forget to also adjust the susceptible population density
    susd[[curr_idx]] = popc2popd(susceptible[[curr_idx]])
  }
  final_dead[[iter]] = terra::app(rast(dead), sum)
  
  correlations[[iter]] = cor(terra::values(ad1400_popc_rast),
                         terra::values(final_dead[[iter]]), 
                         use="complete.obs")
  
  print(paste('trial',iter,'complete'))
}
```

```{r top_correlation_chart, echo=FALSE}
most_corr_idx = which.max(correlations)

plot(terra::values(final_dead[[most_corr_idx]]) ~ terra::values(ad1400_popc_rast),
     xlab = 'Actual Population Decrease',
     ylab = 'Expected Population Decrease')
abline(lm(terra::values(final_dead[[most_corr_idx]]) ~ terra::values(ad1400_popc_rast)))
legend("topleft", legend=paste('Model', most_corr_idx,
                               'Correlation =', round(correlations[[most_corr_idx]], 2)))
```


```{r best_model_result, echo=FALSE}
tm_shape(basemap) +
  tm_rgb(alpha=0.8) +
  tm_shape(final_dead[[most_corr_idx]], raster.downsample=F) +
  tm_raster(alpha=0.7, 
            breaks=c(0.0,
                     100.0,
                     200.0,
                     400.0,
                     800.0,
                     1600.0,
                     3200.0,
                     6400.0,
                     12000.0,
                     24000.0,
                     48000.0),
                     title="",legend.show=T) +
  tm_layout(legend.position=c('left', 'top'),
            frame=FALSE,
            legend.outside=TRUE,
            main.title=paste('Model',most_corr_idx,'Cumulative Dead'))
```


$$
e^{-{x^{\sqrt[2]{3}}}}
$$

## Results

### Placeholder Subsection 1

### Placeholder Subsection 2

## References


<br>\
<div id="refs"></div>